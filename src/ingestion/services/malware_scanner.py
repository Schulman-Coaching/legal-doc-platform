"""
Malware Scanning Service
========================
Integrates with ClamAV daemon and VirusTotal API for malware detection.
Supports multiple scanning backends with fallback capabilities.
"""

import asyncio
import hashlib
import logging
import socket
import struct
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from pathlib import Path
from typing import Any, Optional

import aiohttp

logger = logging.getLogger(__name__)


class ScanStatus(str, Enum):
    """Malware scan status."""
    CLEAN = "clean"
    INFECTED = "infected"
    SUSPICIOUS = "suspicious"
    ERROR = "error"
    TIMEOUT = "timeout"
    SKIPPED = "skipped"


@dataclass
class ScanResult:
    """Result of malware scan."""
    status: ScanStatus
    scanner: str
    scan_time: float  # seconds
    file_hash: str
    threats_found: list[str] = field(default_factory=list)
    details: dict[str, Any] = field(default_factory=dict)
    scanned_at: datetime = field(default_factory=datetime.utcnow)


class MalwareScanner(ABC):
    """Abstract base class for malware scanners."""

    @abstractmethod
    async def scan_file(self, filepath: Path) -> ScanResult:
        """Scan a file for malware."""
        pass

    @abstractmethod
    async def scan_bytes(self, data: bytes, filename: str = "unknown") -> ScanResult:
        """Scan bytes for malware."""
        pass

    @abstractmethod
    async def is_available(self) -> bool:
        """Check if scanner is available."""
        pass


class ClamAVScanner(MalwareScanner):
    """
    ClamAV scanner using clamd daemon.

    Supports both UNIX socket and TCP connections.
    Uses INSTREAM command for in-memory scanning.
    """

    CHUNK_SIZE = 2048

    def __init__(
        self,
        host: str = "localhost",
        port: int = 3310,
        unix_socket: Optional[str] = None,
        timeout: float = 60.0,
    ):
        self.host = host
        self.port = port
        self.unix_socket = unix_socket
        self.timeout = timeout

    async def scan_file(self, filepath: Path) -> ScanResult:
        """Scan a file using ClamAV."""
        start_time = asyncio.get_event_loop().time()

        try:
            # Read file
            with open(filepath, "rb") as f:
                data = f.read()

            # Calculate hash
            file_hash = hashlib.sha256(data).hexdigest()

            # Scan
            result = await self._scan_stream(data)
            scan_time = asyncio.get_event_loop().time() - start_time

            return ScanResult(
                status=result[0],
                scanner="clamav",
                scan_time=scan_time,
                file_hash=file_hash,
                threats_found=result[1],
                details={"filepath": str(filepath)},
            )

        except Exception as e:
            logger.error(f"ClamAV scan error: {e}")
            return ScanResult(
                status=ScanStatus.ERROR,
                scanner="clamav",
                scan_time=asyncio.get_event_loop().time() - start_time,
                file_hash="",
                details={"error": str(e)},
            )

    async def scan_bytes(self, data: bytes, filename: str = "unknown") -> ScanResult:
        """Scan bytes using ClamAV."""
        start_time = asyncio.get_event_loop().time()

        try:
            file_hash = hashlib.sha256(data).hexdigest()
            result = await self._scan_stream(data)
            scan_time = asyncio.get_event_loop().time() - start_time

            return ScanResult(
                status=result[0],
                scanner="clamav",
                scan_time=scan_time,
                file_hash=file_hash,
                threats_found=result[1],
                details={"filename": filename},
            )

        except Exception as e:
            logger.error(f"ClamAV scan error: {e}")
            return ScanResult(
                status=ScanStatus.ERROR,
                scanner="clamav",
                scan_time=asyncio.get_event_loop().time() - start_time,
                file_hash=hashlib.sha256(data).hexdigest(),
                details={"error": str(e), "filename": filename},
            )

    async def _scan_stream(self, data: bytes) -> tuple[ScanStatus, list[str]]:
        """Scan data stream using INSTREAM command."""
        loop = asyncio.get_event_loop()
        return await loop.run_in_executor(None, self._sync_scan_stream, data)

    def _sync_scan_stream(self, data: bytes) -> tuple[ScanStatus, list[str]]:
        """Synchronous stream scanning."""
        sock = self._get_socket()

        try:
            # Send INSTREAM command
            sock.send(b"zINSTREAM\0")

            # Send data in chunks
            offset = 0
            while offset < len(data):
                chunk = data[offset:offset + self.CHUNK_SIZE]
                size = struct.pack("!L", len(chunk))
                sock.send(size + chunk)
                offset += self.CHUNK_SIZE

            # Send zero-length chunk to signal end
            sock.send(struct.pack("!L", 0))

            # Get response
            response = b""
            while True:
                chunk = sock.recv(4096)
                if not chunk:
                    break
                response += chunk
                if b"\0" in response:
                    break

            response = response.decode("utf-8").strip("\0")
            return self._parse_response(response)

        finally:
            sock.close()

    def _get_socket(self) -> socket.socket:
        """Create socket connection to ClamAV."""
        if self.unix_socket:
            sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
            sock.settimeout(self.timeout)
            sock.connect(self.unix_socket)
        else:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(self.timeout)
            sock.connect((self.host, self.port))
        return sock

    def _parse_response(self, response: str) -> tuple[ScanStatus, list[str]]:
        """Parse ClamAV response."""
        if "OK" in response:
            return ScanStatus.CLEAN, []
        elif "FOUND" in response:
            # Extract threat name
            parts = response.split(":")
            if len(parts) >= 2:
                threat = parts[-1].replace("FOUND", "").strip()
                return ScanStatus.INFECTED, [threat]
            return ScanStatus.INFECTED, ["Unknown threat"]
        elif "ERROR" in response:
            return ScanStatus.ERROR, []
        else:
            return ScanStatus.ERROR, []

    async def is_available(self) -> bool:
        """Check if ClamAV is available."""
        try:
            loop = asyncio.get_event_loop()

            def _ping():
                sock = self._get_socket()
                try:
                    sock.send(b"zPING\0")
                    response = sock.recv(1024)
                    return b"PONG" in response
                finally:
                    sock.close()

            return await loop.run_in_executor(None, _ping)

        except Exception as e:
            logger.debug(f"ClamAV not available: {e}")
            return False

    async def get_version(self) -> Optional[str]:
        """Get ClamAV version."""
        try:
            loop = asyncio.get_event_loop()

            def _version():
                sock = self._get_socket()
                try:
                    sock.send(b"zVERSION\0")
                    response = sock.recv(1024)
                    return response.decode("utf-8").strip("\0")
                finally:
                    sock.close()

            return await loop.run_in_executor(None, _version)

        except Exception:
            return None


class VirusTotalScanner(MalwareScanner):
    """
    VirusTotal scanner using their API.

    Submits file hashes first, only uploads if unknown.
    Respects API rate limits.
    """

    API_URL = "https://www.virustotal.com/api/v3"

    def __init__(
        self,
        api_key: str,
        timeout: float = 60.0,
        min_detections_threshold: int = 1,
    ):
        self.api_key = api_key
        self.timeout = timeout
        self.min_detections = min_detections_threshold
        self._session: Optional[aiohttp.ClientSession] = None

    async def _get_session(self) -> aiohttp.ClientSession:
        """Get or create aiohttp session."""
        if self._session is None or self._session.closed:
            self._session = aiohttp.ClientSession(
                headers={"x-apikey": self.api_key},
                timeout=aiohttp.ClientTimeout(total=self.timeout),
            )
        return self._session

    async def scan_file(self, filepath: Path) -> ScanResult:
        """Scan file using VirusTotal."""
        with open(filepath, "rb") as f:
            data = f.read()
        return await self.scan_bytes(data, filepath.name)

    async def scan_bytes(self, data: bytes, filename: str = "unknown") -> ScanResult:
        """Scan bytes using VirusTotal."""
        start_time = asyncio.get_event_loop().time()
        file_hash = hashlib.sha256(data).hexdigest()

        try:
            # First, check if hash is already known
            result = await self._check_hash(file_hash)

            if result is not None:
                result.scan_time = asyncio.get_event_loop().time() - start_time
                result.details["filename"] = filename
                result.details["lookup_type"] = "hash"
                return result

            # Hash unknown, upload file
            result = await self._upload_and_scan(data, filename)
            result.scan_time = asyncio.get_event_loop().time() - start_time
            result.file_hash = file_hash
            return result

        except Exception as e:
            logger.error(f"VirusTotal scan error: {e}")
            return ScanResult(
                status=ScanStatus.ERROR,
                scanner="virustotal",
                scan_time=asyncio.get_event_loop().time() - start_time,
                file_hash=file_hash,
                details={"error": str(e), "filename": filename},
            )

    async def _check_hash(self, file_hash: str) -> Optional[ScanResult]:
        """Check if file hash is already known to VirusTotal."""
        session = await self._get_session()

        try:
            async with session.get(f"{self.API_URL}/files/{file_hash}") as response:
                if response.status == 404:
                    return None

                if response.status != 200:
                    return None

                data = await response.json()
                return self._parse_analysis(data, file_hash)

        except aiohttp.ClientError:
            return None

    async def _upload_and_scan(self, data: bytes, filename: str) -> ScanResult:
        """Upload file to VirusTotal for scanning."""
        session = await self._get_session()
        file_hash = hashlib.sha256(data).hexdigest()

        # Upload file
        form_data = aiohttp.FormData()
        form_data.add_field("file", data, filename=filename)

        async with session.post(f"{self.API_URL}/files", data=form_data) as response:
            if response.status != 200:
                raise Exception(f"Upload failed: {response.status}")

            upload_result = await response.json()
            analysis_id = upload_result["data"]["id"]

        # Wait for analysis
        for _ in range(30):  # Max 5 minutes
            await asyncio.sleep(10)

            async with session.get(f"{self.API_URL}/analyses/{analysis_id}") as response:
                if response.status != 200:
                    continue

                result = await response.json()
                status = result["data"]["attributes"]["status"]

                if status == "completed":
                    return self._parse_analysis_result(result, file_hash)

        return ScanResult(
            status=ScanStatus.TIMEOUT,
            scanner="virustotal",
            scan_time=0,
            file_hash=file_hash,
            details={"analysis_id": analysis_id},
        )

    def _parse_analysis(self, data: dict, file_hash: str) -> ScanResult:
        """Parse VirusTotal file report."""
        attrs = data.get("data", {}).get("attributes", {})
        stats = attrs.get("last_analysis_stats", {})

        malicious = stats.get("malicious", 0)
        suspicious = stats.get("suspicious", 0)
        total = sum(stats.values())

        threats = []
        results = attrs.get("last_analysis_results", {})
        for engine, result in results.items():
            if result.get("category") in ["malicious", "suspicious"]:
                threat_name = result.get("result", "Unknown")
                threats.append(f"{engine}: {threat_name}")

        if malicious >= self.min_detections:
            status = ScanStatus.INFECTED
        elif suspicious > 0:
            status = ScanStatus.SUSPICIOUS
        else:
            status = ScanStatus.CLEAN

        return ScanResult(
            status=status,
            scanner="virustotal",
            scan_time=0,
            file_hash=file_hash,
            threats_found=threats,
            details={
                "malicious": malicious,
                "suspicious": suspicious,
                "total_engines": total,
                "stats": stats,
            },
        )

    def _parse_analysis_result(self, data: dict, file_hash: str) -> ScanResult:
        """Parse VirusTotal analysis result."""
        attrs = data.get("data", {}).get("attributes", {})
        stats = attrs.get("stats", {})

        malicious = stats.get("malicious", 0)
        suspicious = stats.get("suspicious", 0)

        threats = []
        results = attrs.get("results", {})
        for engine, result in results.items():
            if result.get("category") in ["malicious", "suspicious"]:
                threat_name = result.get("result", "Unknown")
                threats.append(f"{engine}: {threat_name}")

        if malicious >= self.min_detections:
            status = ScanStatus.INFECTED
        elif suspicious > 0:
            status = ScanStatus.SUSPICIOUS
        else:
            status = ScanStatus.CLEAN

        return ScanResult(
            status=status,
            scanner="virustotal",
            scan_time=0,
            file_hash=file_hash,
            threats_found=threats,
            details={
                "malicious": malicious,
                "suspicious": suspicious,
                "stats": stats,
            },
        )

    async def is_available(self) -> bool:
        """Check if VirusTotal API is available."""
        try:
            session = await self._get_session()
            async with session.get(f"{self.API_URL}/users/{self.api_key[:32]}") as response:
                return response.status in [200, 401, 403]
        except Exception:
            return False

    async def close(self):
        """Close the aiohttp session."""
        if self._session and not self._session.closed:
            await self._session.close()


class CompositeMalwareScanner(MalwareScanner):
    """
    Composite scanner that uses multiple backends.

    Scans with all available scanners and aggregates results.
    """

    def __init__(self, scanners: list[MalwareScanner]):
        self.scanners = scanners

    async def scan_file(self, filepath: Path) -> ScanResult:
        """Scan file with all available scanners."""
        with open(filepath, "rb") as f:
            data = f.read()
        return await self.scan_bytes(data, filepath.name)

    async def scan_bytes(self, data: bytes, filename: str = "unknown") -> ScanResult:
        """Scan bytes with all available scanners."""
        start_time = asyncio.get_event_loop().time()
        file_hash = hashlib.sha256(data).hexdigest()

        # Run all scanners concurrently
        results = await asyncio.gather(*[
            s.scan_bytes(data, filename)
            for s in self.scanners
            if await s.is_available()
        ], return_exceptions=True)

        # Aggregate results
        all_threats = []
        worst_status = ScanStatus.CLEAN
        scanner_details = {}

        for result in results:
            if isinstance(result, Exception):
                continue

            scanner_details[result.scanner] = {
                "status": result.status.value,
                "threats": result.threats_found,
            }

            all_threats.extend(result.threats_found)

            # Track worst status
            if result.status == ScanStatus.INFECTED:
                worst_status = ScanStatus.INFECTED
            elif result.status == ScanStatus.SUSPICIOUS and worst_status != ScanStatus.INFECTED:
                worst_status = ScanStatus.SUSPICIOUS

        scan_time = asyncio.get_event_loop().time() - start_time

        return ScanResult(
            status=worst_status,
            scanner="composite",
            scan_time=scan_time,
            file_hash=file_hash,
            threats_found=list(set(all_threats)),
            details={"scanner_results": scanner_details},
        )

    async def is_available(self) -> bool:
        """Check if any scanner is available."""
        for scanner in self.scanners:
            if await scanner.is_available():
                return True
        return False
