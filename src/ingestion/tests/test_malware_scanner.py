"""
Tests for Malware Scanner
=========================
"""

import pytest
from pathlib import Path
from unittest.mock import patch, MagicMock, AsyncMock
import tempfile

from ..services.malware_scanner import (
    ClamAVScanner,
    VirusTotalScanner,
    CompositeMalwareScanner,
    ScanStatus,
    ScanResult,
)


class TestClamAVScanner:
    """Test suite for ClamAV scanner."""

    @pytest.fixture
    def scanner(self):
        """Create ClamAV scanner instance."""
        return ClamAVScanner(
            host="localhost",
            port=3310,
            timeout=30.0,
        )

    @pytest.fixture
    def sample_file(self):
        """Create sample file for testing."""
        with tempfile.NamedTemporaryFile(suffix=".pdf", delete=False) as f:
            f.write(b"%PDF-1.4\nSample content for testing")
            return Path(f.name)

    @pytest.mark.asyncio
    async def test_parse_clean_response(self, scanner):
        """Test parsing clean scan response."""
        response = "stream: OK"

        status, threats = scanner._parse_response(response)

        assert status == ScanStatus.CLEAN
        assert threats == []

    @pytest.mark.asyncio
    async def test_parse_infected_response(self, scanner):
        """Test parsing infected scan response."""
        response = "stream: Eicar-Signature FOUND"

        status, threats = scanner._parse_response(response)

        assert status == ScanStatus.INFECTED
        assert "Eicar-Signature" in threats[0]

    @pytest.mark.asyncio
    async def test_parse_error_response(self, scanner):
        """Test parsing error response."""
        response = "ERROR: Could not scan file"

        status, threats = scanner._parse_response(response)

        assert status == ScanStatus.ERROR
        assert threats == []

    @pytest.mark.asyncio
    async def test_scan_file_connection_error(self, scanner, sample_file):
        """Test handling of connection error."""
        # ClamAV is not running in test environment
        result = await scanner.scan_file(sample_file)

        # Should return error status when can't connect
        assert result.status == ScanStatus.ERROR
        assert result.scanner == "clamav"
        assert "error" in result.details

        sample_file.unlink()

    @pytest.mark.asyncio
    async def test_scan_bytes_generates_hash(self, scanner):
        """Test that scan_bytes generates correct hash."""
        content = b"Test content for hashing"

        with patch.object(scanner, "_scan_stream", return_value=(ScanStatus.CLEAN, [])):
            result = await scanner.scan_bytes(content, "test.txt")

            assert result.file_hash is not None
            assert len(result.file_hash) == 64  # SHA-256

    @pytest.mark.asyncio
    async def test_is_available_when_down(self, scanner):
        """Test is_available when ClamAV is not running."""
        available = await scanner.is_available()

        # Should be False when can't connect
        assert available is False


class TestVirusTotalScanner:
    """Test suite for VirusTotal scanner."""

    @pytest.fixture
    def scanner(self):
        """Create VirusTotal scanner instance."""
        return VirusTotalScanner(
            api_key="test_api_key_12345",
            timeout=30.0,
        )

    @pytest.mark.asyncio
    async def test_parse_clean_analysis(self, scanner):
        """Test parsing clean analysis result."""
        data = {
            "data": {
                "attributes": {
                    "last_analysis_stats": {
                        "malicious": 0,
                        "suspicious": 0,
                        "harmless": 50,
                        "undetected": 10,
                    },
                    "last_analysis_results": {},
                }
            }
        }

        result = scanner._parse_analysis(data, "abc123")

        assert result.status == ScanStatus.CLEAN
        assert result.threats_found == []
        assert result.details["malicious"] == 0

    @pytest.mark.asyncio
    async def test_parse_infected_analysis(self, scanner):
        """Test parsing infected analysis result."""
        data = {
            "data": {
                "attributes": {
                    "last_analysis_stats": {
                        "malicious": 3,
                        "suspicious": 1,
                        "harmless": 40,
                        "undetected": 16,
                    },
                    "last_analysis_results": {
                        "Engine1": {"category": "malicious", "result": "Trojan.Gen"},
                        "Engine2": {"category": "malicious", "result": "Malware.X"},
                        "Engine3": {"category": "suspicious", "result": "Heuristic.Y"},
                        "Engine4": {"category": "harmless", "result": None},
                    },
                }
            }
        }

        result = scanner._parse_analysis(data, "abc123")

        assert result.status == ScanStatus.INFECTED
        assert len(result.threats_found) == 3
        assert result.details["malicious"] == 3

    @pytest.mark.asyncio
    async def test_parse_suspicious_analysis(self, scanner):
        """Test parsing suspicious (but not malicious) analysis."""
        data = {
            "data": {
                "attributes": {
                    "last_analysis_stats": {
                        "malicious": 0,
                        "suspicious": 2,
                        "harmless": 48,
                        "undetected": 10,
                    },
                    "last_analysis_results": {
                        "Engine1": {"category": "suspicious", "result": "Heuristic.A"},
                    },
                }
            }
        }

        result = scanner._parse_analysis(data, "abc123")

        assert result.status == ScanStatus.SUSPICIOUS
        assert len(result.threats_found) == 1

    @pytest.mark.asyncio
    async def test_custom_detection_threshold(self):
        """Test custom minimum detections threshold."""
        scanner = VirusTotalScanner(
            api_key="test_key",
            min_detections_threshold=5,  # Require 5 detections
        )

        data = {
            "data": {
                "attributes": {
                    "last_analysis_stats": {
                        "malicious": 3,  # Less than threshold
                        "suspicious": 0,
                        "harmless": 57,
                        "undetected": 0,
                    },
                    "last_analysis_results": {},
                }
            }
        }

        result = scanner._parse_analysis(data, "abc123")

        # Should be clean because threshold not met
        assert result.status == ScanStatus.CLEAN


class TestCompositeMalwareScanner:
    """Test suite for composite scanner."""

    @pytest.fixture
    def mock_scanner1(self):
        """Create mock scanner 1."""
        scanner = MagicMock(spec=ClamAVScanner)
        scanner.is_available = AsyncMock(return_value=True)
        scanner.scan_bytes = AsyncMock(return_value=ScanResult(
            status=ScanStatus.CLEAN,
            scanner="scanner1",
            scan_time=0.5,
            file_hash="abc",
        ))
        return scanner

    @pytest.fixture
    def mock_scanner2(self):
        """Create mock scanner 2."""
        scanner = MagicMock(spec=VirusTotalScanner)
        scanner.is_available = AsyncMock(return_value=True)
        scanner.scan_bytes = AsyncMock(return_value=ScanResult(
            status=ScanStatus.CLEAN,
            scanner="scanner2",
            scan_time=1.0,
            file_hash="abc",
        ))
        return scanner

    @pytest.mark.asyncio
    async def test_composite_all_clean(self, mock_scanner1, mock_scanner2):
        """Test composite scanner when all scanners report clean."""
        composite = CompositeMalwareScanner([mock_scanner1, mock_scanner2])

        result = await composite.scan_bytes(b"test content", "test.txt")

        assert result.status == ScanStatus.CLEAN
        assert result.scanner == "composite"
        assert "scanner_results" in result.details

    @pytest.mark.asyncio
    async def test_composite_one_infected(self, mock_scanner1, mock_scanner2):
        """Test composite scanner when one reports infected."""
        mock_scanner1.scan_bytes = AsyncMock(return_value=ScanResult(
            status=ScanStatus.INFECTED,
            scanner="scanner1",
            scan_time=0.5,
            file_hash="abc",
            threats_found=["Trojan.Gen"],
        ))

        composite = CompositeMalwareScanner([mock_scanner1, mock_scanner2])

        result = await composite.scan_bytes(b"test content", "test.txt")

        assert result.status == ScanStatus.INFECTED
        assert "Trojan.Gen" in result.threats_found

    @pytest.mark.asyncio
    async def test_composite_one_suspicious(self, mock_scanner1, mock_scanner2):
        """Test composite scanner when one reports suspicious."""
        mock_scanner1.scan_bytes = AsyncMock(return_value=ScanResult(
            status=ScanStatus.SUSPICIOUS,
            scanner="scanner1",
            scan_time=0.5,
            file_hash="abc",
            threats_found=["Heuristic.Suspicious"],
        ))

        composite = CompositeMalwareScanner([mock_scanner1, mock_scanner2])

        result = await composite.scan_bytes(b"test content", "test.txt")

        assert result.status == ScanStatus.SUSPICIOUS

    @pytest.mark.asyncio
    async def test_composite_unavailable_scanner_skipped(self, mock_scanner1, mock_scanner2):
        """Test that unavailable scanners are skipped."""
        mock_scanner1.is_available = AsyncMock(return_value=False)

        composite = CompositeMalwareScanner([mock_scanner1, mock_scanner2])

        result = await composite.scan_bytes(b"test content", "test.txt")

        # Only scanner2 should have been called
        mock_scanner1.scan_bytes.assert_not_called()
        mock_scanner2.scan_bytes.assert_called_once()

    @pytest.mark.asyncio
    async def test_composite_is_available(self, mock_scanner1, mock_scanner2):
        """Test composite is_available when at least one scanner available."""
        composite = CompositeMalwareScanner([mock_scanner1, mock_scanner2])

        available = await composite.is_available()

        assert available is True

    @pytest.mark.asyncio
    async def test_composite_not_available(self):
        """Test composite is_available when no scanners available."""
        mock1 = MagicMock()
        mock1.is_available = AsyncMock(return_value=False)
        mock2 = MagicMock()
        mock2.is_available = AsyncMock(return_value=False)

        composite = CompositeMalwareScanner([mock1, mock2])

        available = await composite.is_available()

        assert available is False


class TestScanResult:
    """Test ScanResult dataclass."""

    def test_scan_result_defaults(self):
        """Test ScanResult default values."""
        result = ScanResult(
            status=ScanStatus.CLEAN,
            scanner="test",
            scan_time=1.0,
            file_hash="abc123",
        )

        assert result.threats_found == []
        assert result.details == {}
        assert result.scanned_at is not None

    def test_scan_result_with_threats(self):
        """Test ScanResult with threats."""
        result = ScanResult(
            status=ScanStatus.INFECTED,
            scanner="clamav",
            scan_time=0.5,
            file_hash="def456",
            threats_found=["Trojan.Gen", "Worm.XYZ"],
        )

        assert len(result.threats_found) == 2
        assert "Trojan.Gen" in result.threats_found
